/*
 * CS-252 Spring 2017
 * fiz.y: parser for the FIZ interpreter
 */
/********************************************************************************
 * Beginning of Section 1: Definition of tokens and non-terminal in the grammar *
 ********************************************************************************/ 

// tokens are generated by the lexical analyzer specified in fiz.l
// The ID token is used for function name, formal argument name, and usage of argument in function body
// its value is a string.  The token ID has a string value associated with it, here <string_val> refers
// to the "char *string_val" member in %union below
%token <string_val> ID			

// The token NUMBER has a integer value associated with it, here <number_val> refers to the 
// int number_val member in %union below

%token <number_val> NUMBER 
//%token <const_val> VALUE

// These tokens do not have associated values
%token DEFINE HALT OPENPAR CLOSEPAR OPENBRACK CLOSEBRACK

// This declares that in the grammar, the non terminals expr, expr_list, and arg_list have 
// a value "struct TREE_NODE *node_val" associated with it
%type <node_val> expr expr_list arg_list 
%type <const_val> const_expr const_exprs
//%type <temp> list
//%type <temp1> item

%union    {
        char   *string_val;
        int    number_val;
        struct TREE_NODE *node_val;
		struct VALUE *const_val;
}

%{
/********************************************************************************
 * Beginning of Section 2: C data type and global variable definitions to be    *
 *  included in the generated y.tab.c file                                      *
 ********************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

void yyerror(const char * s);
void prompt();
int yylex();

#define MAX_FUNCTIONS 1000
#define MAX_ARGUMENTS 10
#define NUM_BUILTIN   5

typedef enum
{
	INT,
	EMPTY,
	LIST,
	TAIL_LIST
} VALUE_TYPE;
//ADD A NEW DATA TYPE

// The types of nodes that may occur in a syntax tree
enum NODE_TYPE
{
    HALT_NODE,      // corresponds to (halt)
    BUILTIN_FUNC,   // corresponds to built-in functions such as (inc ...) (dec ...) (ifz ... ... ...)
    FUNC_CALL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS 
                    // before the function is resolved, i.e., fname are still stored as strings
    FUNC_EVAL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS
                    // after the function has been resolved, that is, matching function has been found
    NUMBER_NODE,    // 
    ARG_NAME,       // corresponds to the usage of an ID in the body of the definition of a function,
                    // it indicates the usage of an argument, we are keeping it as a string
    ARG_INDEX,      // corresponds to the usage of an ID in the body of the definition of a function,
                    // it has been resolved to indicate the index of the argument 
    ARG_LIST,        // corresponds to a list of formal arguments constructed during parsing in a function definition
	CONST_VALUE //FLIZ added
};



struct VALUE 
{
	int data;
	VALUE_TYPE type;
	struct VALUE * head;
	struct VALUE * tail;
};

// Below is the data type for a node in the syntax tree
struct TREE_NODE
{
    enum NODE_TYPE type;
    union {
        struct {
            struct BUILTIN_DECL *decl;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } builtin_func;                      // For BUILTIN_FUNC
        struct {
            char *name;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_call;                        // For FUNC_CALL
        struct {
            struct FUNC_DECL *func;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_eval;                        // For FUNC_EVAL
        struct {
            int    numArgs;
            char * argNames[MAX_ARGUMENTS];
        } arg_list;                         // For ARG_LIST
        int    intValue;                    // For NUMBER_NODE and ARG_INDEX
        char   *strValue;                   // For ARG_NAME
		struct VALUE *constValue;
    };
};

// Information we maintain for each built-in function
struct BUILTIN_DECL {
	char *name;
	int numArgs;
	struct VALUE *(* body)(struct TREE_NODE* node, struct VALUE **env);		// Body of the function
	void (* print)(FILE* stream, struct TREE_NODE* node, struct VALUE **env, int level);
					// support printing that occurs when tracing is on
};

// Information we maintain for each defined function
struct FUNC_DECL {
    char *name;              // Function name
    int  numArgs;            // Number of arguments
    char *argNames[MAX_ARGUMENTS];         // Names of formal arguments
    int  resolved;           // Whether the body expression has been resolved.
    struct TREE_NODE * body; // Point to the expression representing the body of a function
};

// Stores the definitions of functions defined using (define ...)
struct FUNC_DECL functions[MAX_FUNCTIONS];
int numFuncs = 0;

// Global variables
int err_value = 0;
int loading = 0;
int tracing = 0;
int depth = 0;

// Find a builtin function by name
struct BUILTIN_DECL * find_builtin(char *name);

// Find a function by name
struct FUNC_DECL * find_function(char *name);

// Resolve the body of a function to prepare it for evaluation
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf);

// Evaluate a function
//int eval(struct TREE_NODE * node, int *env);
struct VALUE *eval(struct TREE_NODE * node, struct VALUE **env);//FLIZ FUNCTION SIGNATURE CHANGE

// Free a syntax tree that is no longer needed

//struct VALUE * newnode(VALUE_TYPE type, struct VALUE * head, struct VALUE * tail);
void print_value(struct VALUE * v);



struct VALUE * eval_head(struct TREE_NODE * node, struct VALUE **env);
struct VALUE * eval_tail(struct TREE_NODE * node, struct VALUE **env);
struct VALUE * eval_list(struct TREE_NODE * node, struct VALUE **env);
struct VALUE * eval_ifn(struct TREE_NODE * node, struct VALUE **env);
struct VALUE * eval_ifa(struct TREE_NODE * node, struct VALUE **env);
//int eval_inc(struct TREE_NODE * node, int *env);
struct VALUE * eval_inc(struct TREE_NODE * node, struct VALUE **env);

//int eval_dec(struct TREE_NODE * node, int *env);
struct VALUE * eval_dec(struct TREE_NODE * node, struct VALUE **env);

//int eval_ifz(struct TREE_NODE * node, int *env);
struct VALUE *eval_ifz(struct TREE_NODE * node, struct VALUE **env);

// Support printing when tracing is on
//void print_inc(FILE *stream, struct TREE_NODE * node, int *env, int level);
void print_inc(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
//void print_dec(FILE *stream, struct TREE_NODE * node, int *env, int level);
void print_dec(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
//void print_ifz(FILE *stream, struct TREE_NODE * node, int *env, int level);
void print_ifz(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);

void print_head(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_tail(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_list(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_ifn(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_ifa(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);

// The global variable of all builtin functions
struct BUILTIN_DECL builtin_functions[NUM_BUILTIN] = {

	{"head",1, &eval_head, &print_head},
	{"tail",1, &eval_tail, &print_tail},
	{"list", 2, &eval_list, &print_list},
	{"ifn", 3, &eval_ifn, &print_ifn},
	{"ifa", 3, &eval_ifa, &print_ifa}
};

%}

%%
/********************************************************************************
 * Beginning of Section 3: Grammar production rule definitions and associated   *
 *  C code                                                                      *
 ********************************************************************************/ 

statements:
 statement 
| 
 statements statement
;

statement:
  OPENPAR DEFINE OPENPAR ID arg_list CLOSEPAR expr CLOSEPAR     // define a function`
  {
    if (find_builtin($4) != NULL) {
        fprintf(stderr, "Cannot redefine builtin function %s.\n", $4);
    } 
	else if (find_function($4) != NULL) {
        fprintf(stderr, "Function %s already defined.\n", $4);
    } 
	else if ($5-> arg_list.numArgs > MAX_ARGUMENTS) {
        fprintf(stderr, "Sorry, we allow only %d arguments in a function.", MAX_ARGUMENTS);
    } 
	else if (numFuncs == MAX_FUNCTIONS) {
        fprintf(stderr, "Sorry, we allow only %d number of functions to be defined. \n", MAX_FUNCTIONS);
    } 
	else {   // No error, add definition for the function
	    int i;
        functions[numFuncs].name = $4; 
        functions[numFuncs].numArgs = $5->arg_list.numArgs;
		for (i=0; i<$5->arg_list.numArgs; i++) {
            functions[numFuncs].argNames[i] = $5->arg_list.argNames[i];
		}
		free($5);
        functions[numFuncs].body = $7;
		// Do not resolve now, because the body may use function not yet defined. 
        functions[numFuncs].resolved = 0;	
        numFuncs++;
        printf("Function %s defined.\n", $4);
    }
  }
| 
  expr		// An expression
  {
    resolve($1, NULL);
	printf(" ");
    if (err_value == 0) {
		struct VALUE * v = eval($1, NULL);
		//print_value($1->constValue);
		print_value(v);		
		printf("\n");      
    }
	//printf("\n"); 
    err_value = 0;
  }
;

arg_list:
  ID 
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_LIST;
    node -> arg_list.numArgs = 1;
    node -> arg_list.argNames[0] = $1;
    $$ = node;
  }
| arg_list ID
  {
    if ($1 -> arg_list.numArgs >= MAX_ARGUMENTS) {
        fprintf (stderr, "Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);		
        free($2);
		err_value = 1;
    } else {
        $1 -> arg_list.argNames[$1->arg_list.numArgs] = $2;
        $1 -> arg_list.numArgs++;
    }
    $$ = $1;
  }
  
expr_list:        
  expr
  {
    // expr_list can be used only as actual arguments in a function invocation
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = FUNC_CALL;
    node -> func_call.numArgs = 1;
    node -> func_call.args[0] = $1;
    $$ = node;
  }
| expr_list expr
  {
    if ($1 -> func_call.numArgs >= MAX_ARGUMENTS) {
        printf ("Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);
        //free_tree($2);
		err_value = 2;
    } else {
        $1 -> func_call.args[$1->func_call.numArgs] = $2;
        $1 -> func_call.numArgs++;
    }
    $$ = $1;
  }
;

//RECURSIVE GRAMMER FOR LIST
const_exprs: 
const_expr 
{	
	struct VALUE * val = malloc(sizeof(struct VALUE));
	val->type = LIST;	
	val->head = $1;
	val->tail = NULL;
	$$ = val;
 }
|
const_expr const_exprs
{
	struct VALUE * val = malloc(sizeof(struct VALUE));
	val->type = LIST;
	val->head = $1;
	struct VALUE *tail = $2;
	tail->type = TAIL_LIST;	
	val->tail = tail;
	$$ = val;
 }
;


const_expr:
	NUMBER
	  {
		struct VALUE * value = (struct VALUE *) malloc(sizeof(struct VALUE));
		value -> type = INT;
		value -> data = $1;
		$$ = value;
	  }
|
	OPENBRACK const_exprs CLOSEBRACK 
	{
		$$ = $2;	
	}
|
	OPENBRACK CLOSEBRACK 
	{
		struct VALUE * value = (struct VALUE *) malloc(sizeof(struct VALUE));
		value -> type = EMPTY;
		$$ = value;
	}
;


expr: 
  OPENPAR HALT CLOSEPAR
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = HALT_NODE;
    $$ = node;
  }
|
  /**NUMBER
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = NUMBER_NODE;
    node -> intValue = $1;
    $$ = node;
  }**/
	const_expr
	{
		struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
		node->type = CONST_VALUE;
		node->constValue = $1;
		$$ = node;
	}
|

  ID
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_NAME;
    node -> strValue = $1;
    $$ = node;
  }
|
 OPENPAR ID expr_list CLOSEPAR
  {
    struct BUILTIN_DECL *builtin = find_builtin($2);
    $3 -> func_call.name = $2;
	if (builtin != NULL) {	// Usage of a built-in function
	    if (builtin->numArgs != $3->func_call.numArgs) {
		    fprintf (stderr, "The built-in function %s expects %d arguments; you have %d.", 
			                 builtin->name, builtin->numArgs, $3->func_call.numArgs);
			err_value = 3;
		} else {
	        $3 -> type = BUILTIN_FUNC;
		    $3 -> builtin_func.decl = builtin;
            free($2);			// Name string no longer needed
		}
    }
    $$ = $3;
  }
;

%%
/********************************************************************************
 * Beginning of Section 4: C functions to be included in the y.tab.c.           *
 ********************************************************************************/ 

/* Free an expression tree that is no longer needed.  */

/* Print an expression when tracing is on */

struct BUILTIN_DECL * find_builtin(char *name)
{
    int i;
    for (i=0; i<NUM_BUILTIN; i++) {
        if (strcmp(builtin_functions[i].name, name) == 0)
            return &builtin_functions[i];
    }
    return NULL;
}

 
struct FUNC_DECL * find_function(char *name)
{
    int i;
    for (i=0; i<numFuncs; i++) {
        if (! strcmp(functions[i].name, name))
            return &functions[i];
    }
    return NULL;
}

/* Resolve an expression pointed to by node, possibly in the context of a function 
   body.  */
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf)
{
    struct FUNC_DECL *f = NULL;

    int i;
    switch(node->type)
    {
        case ARG_NAME:        // Use of an argument
            if (cf != NULL) { //
                for (i=0; i<cf->numArgs; i++) {
                    if (! strcmp(node->strValue, cf->argNames[i])) {
                        free(node->strValue);
                        node->type = ARG_INDEX;
                        node->intValue = i;
                        break;
                    }
                }
            }
            if (node->type != ARG_INDEX) {
                fprintf(stderr, "Usage of identifier %s undefined\n", node->strValue);
                err_value = 1;
            }
            break;
            
        case FUNC_CALL:
            f = find_function(node->func_call.name);
            if (f == NULL) {
                fprintf(stderr, "Function %s not found\n", node->func_call.name);
                err_value = 1;
                break;
            }
            if (f->numArgs != node->func_call.numArgs) {
                fprintf(stderr, "Usage of function %s has %d arguments, definition of function %s has %d arguments.\n", 
                       f->name, node->func_eval.numArgs, f->name, f->numArgs);
                err_value = 1;
                break;
            }
            free(node->func_call.name);
            for (i=0; i<f->numArgs; i++) {
                resolve(node->func_call.args[i], cf);
            }
            node->type = FUNC_EVAL;
            node->func_eval.func = f;
            break;

        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                resolve(node->builtin_func.args[i], cf);
            }
			break;
    }
}

//Evaluates an expression node
//int eval(struct TREE_NODE * node, int *env)
struct VALUE *eval(struct TREE_NODE *node, struct VALUE **env) //FLIZ CHANGES TO FUNCTION SIGNATURE
{
    struct FUNC_DECL   *f;
    int i;//, v;
    //int e[MAX_ARGUMENTS];
	struct VALUE* e[MAX_ARGUMENTS];
	struct VALUE *v;
    depth ++;

    switch(node->type)
    {
		case CONST_VALUE://ADDED FOR FLIZ
			v = node->constValue;		
			break;
      	case ARG_INDEX:
            v = env[node->intValue];
            break;
        case BUILTIN_FUNC:
            v = (node->builtin_func.decl->body)(node, env);
            break;
        case HALT_NODE:
            fprintf(stderr, "Halted\n");
            exit(1);
        case FUNC_EVAL:
            f = node->func_eval.func;
            if (! f->resolved) {
                resolve(f->body, f);
            }
            for (i=0; i<f->numArgs; i++) {
                e[i] = eval(node->func_eval.args[i], env);
            }
            /*if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("Evaluating (%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]->data);
                }
                printf(")\n");
            }*/
            
            v = eval(f->body, e);
            
            /*if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("(%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]);
                }
                printf(") = %d\n", v);
            }*/
            break;
			
        default:
            fprintf(stderr, "Unexpected node %d\n", node->type); 
            exit(3);
    }
    depth --;
    return v;
}

/*********************************************************
 * Begin of supporting code for the built-in functions.  *
 *********************************************************/

struct VALUE * eval_head(struct TREE_NODE * node, struct VALUE **env) 
{
	struct VALUE * v = eval(node->builtin_func.args[0], env);
	return v->head;
}

void print_head(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level) 
{
}

struct VALUE * eval_tail(struct TREE_NODE * node, struct VALUE **env) 
{
	struct VALUE * v = eval(node->builtin_func.args[0], env);	
	if (v->tail == NULL) {
		v->tail = malloc(sizeof(struct VALUE));
		v->tail->type = EMPTY;	
	} else {
		v->tail->type = LIST;	
	}
	return v->tail;
}

void print_tail(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level) 
{
}

struct VALUE * eval_list(struct TREE_NODE * node, struct VALUE **env) 
{
	struct VALUE * head = eval(node->builtin_func.args[0], env);
	struct VALUE * tail = eval(node->builtin_func.args[1], env);
	tail->type = TAIL_LIST;
	struct VALUE * value = (struct VALUE *) malloc(sizeof(struct VALUE));
	value->type = LIST;
	value->head = head;
	value->tail = tail;
	return value;
}

void print_list(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level) 
{
}

struct VALUE * eval_ifn(struct TREE_NODE * node, struct VALUE **env) 
{
	struct VALUE * first = eval(node->builtin_func.args[0], env);
	struct VALUE * second = eval(node->builtin_func.args[1], env);
	struct VALUE * third = eval(node->builtin_func.args[2], env);
	if (first == NULL || first->type == EMPTY) {
		return 	second;
	}
	return third;

}

void print_ifn(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level)
{
}

struct VALUE * eval_ifa(struct TREE_NODE * node, struct VALUE **env) 
{
	struct VALUE * first = eval(node->builtin_func.args[0], env);
	struct VALUE * second = eval(node->builtin_func.args[1], env);
	struct VALUE * third = eval(node->builtin_func.args[2], env);
	if (first->type == INT) {
		return second;
	}
	return third;
}

void print_ifa(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level)
{
}

struct VALUE * eval_inc(struct TREE_NODE * node, struct VALUE **env)
{
	struct VALUE * v = eval(node->builtin_func.args[0], env);
	v->data += 1;
    //return eval(node->builtin_func.args[0], env) + 1;
	return v;
}

void print_inc(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level)
{
	fprintf (stream, " (inc ..)");
}
            
struct VALUE * eval_dec(struct TREE_NODE * node, struct VALUE **env)
{
    struct VALUE * v = eval(node->builtin_func.args[0], env);
	v->data -= 1;
    //int num = v->data - 1;
	if (v->data < 0) {
	    fprintf(stderr, "Encountering a negative number.  Exiting.\n");
		exit(1);
	}
	return v;
}

void print_dec(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level)
{
	fprintf (stream, " (dec ..)");
}

struct VALUE * eval_ifz(struct TREE_NODE * node, struct VALUE **env)
{
    int i;
    struct VALUE * v = eval(node->builtin_func.args[0], env);
            
    /*if (tracing) {
        for (i=0; i<depth; i++) {
            printf (" ");
        }
        printf("Evaluating (ifz %d", v);
        print_node(node->builtin_func.args[1], env, 2);
        print_node(node->builtin_func.args[2], env, 2);
        printf(")\n");
    }*/
    if (v->data == 0) 
        v = eval(node->builtin_func.args[1], env);
    else
        v = eval(node->builtin_func.args[2], env);
    return v;
}

void print_ifz(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level)
{
    if (level == 0) {
        printf (" (ifz .. .. ..)");
    } else {
        printf (" (ifz");
        //print_node(node->builtin_func.args[0], env, level-1);
        //print_node(node->builtin_func.args[1], env, level-1);
       // print_node(node->builtin_func.args[2], env, level-1);
        printf (")");
    }
}

/*********************************************************
 * End of supporting code for the built-in functions.  *
 *********************************************************/

void yyerror(const char * s)
{
    fprintf(stderr,"%s", s);
}

void prompt()
{
    if (! loading) {
        printf("fliz> ");
    }
}

int main(int argc, char *argv[])
{
    prompt();
    yyparse();
    return 0;
}
void print_value(struct VALUE * v){
	switch(v->type){
		case EMPTY:
			printf("[ ]");
			break;
		case INT:
			printf("%d ", v->data);
			break;
		case LIST:
			printf("[ ");
			print_value(v->head);
			if (v->tail != NULL) {
				print_value(v->tail);
			}
			printf("] ");
			break;
		case TAIL_LIST:
			
			print_value(v->head);
			if (v->tail != NULL) {
				print_value(v->tail);
			}
			
			break;
		default:
			break;
	}
}
