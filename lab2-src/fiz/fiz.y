/*
 * CS-252 Spring 2017
 * fiz.y: parser for the FIZ interpreter
 */


/********************************************************************************
 * Beginning of Section 1: Definition of tokens and non-terminal in the grammar *
 ********************************************************************************/ 

// tokens are generated by the lexical analyzer specified in fiz.l
// The ID token is used for function name, formal argument name, and usage of argument in function body
// its value is a string.  The token ID has a string value associated with it, here <string_val> refers
// to the "char *string_val" member in %union below
%token <string_val> ID			

// The token NUMBER has a integer value associated with it, here <number_val> refers to the 
// int number_val member in %union below
%token <number_val> NUMBER 

// These tokens do not have associated values
%token DEFINE HALT OPENPAR CLOSEPAR

// This declares that in the grammar, the non terminals expr, expr_list, and arg_list have 
// a value "struct TREE_NODE *node_val" associated with it
%type <node_val> expr expr_list arg_list

%union    {
        char   *string_val;
        int    number_val;
        struct TREE_NODE *node_val;
}

%{
/********************************************************************************
 * Beginning of Section 2: C data type and global variable definitions to be    *
 *  included in the generated y.tab.c file                                      *
 ********************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

void yyerror(const char * s);
void prompt();
int yylex();

#define MAX_FUNCTIONS 1000
#define MAX_ARGUMENTS 10
#define NUM_BUILTIN   3

// The types of nodes that may occur in a syntax tree
enum NODE_TYPE
{
    HALT_NODE,      // corresponds to (halt)
    BUILTIN_FUNC,   // corresponds to built-in functions such as (inc ...) (dec ...) (ifz ... ... ...)
    FUNC_CALL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS 
                    // before the function is resolved, i.e., fname are still stored as strings
    FUNC_EVAL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS
                    // after the function has been resolved, that is, matching function has been found
    NUMBER_NODE,    // 
    ARG_NAME,       // corresponds to the usage of an ID in the body of the definition of a function,
                    // it indicates the usage of an argument, we are keeping it as a string
    ARG_INDEX,      // corresponds to the usage of an ID in the body of the definition of a function,
                    // it has been resolved to indicate the index of the argument 
    ARG_LIST        // corresponds to a list of formal arguments constructed during parsing in a function definition
};

// Below is the data type for a node in the syntax tree
struct TREE_NODE
{
    enum NODE_TYPE type;
    union {
        struct {
            struct BUILTIN_DECL *decl;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } builtin_func;                      // For BUILTIN_FUNC
        struct {
            char *name;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_call;                        // For FUNC_CALL
        struct {
            struct FUNC_DECL *func;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_eval;                        // For FUNC_EVAL
        struct {
            int    numArgs;
            char * argNames[MAX_ARGUMENTS];
        } arg_list;                         // For ARG_LIST
        int    intValue;                    // For NUMBER_NODE and ARG_INDEX
        char   *strValue;                   // For ARG_NAME
    };
};

// Information we maintain for each built-in function
struct BUILTIN_DECL {
	char *name;
	int numArgs;
	int (* body)(struct TREE_NODE* node, int *env);		// Body of the function
	void (* print)(FILE* stream, struct TREE_NODE* node, int *env, int level) ;
					// support printing that occurs when tracing is on
};

// Information we maintain for each defined function
struct FUNC_DECL {
    char *name;              // Function name
    int  numArgs;            // Number of arguments
    char *argNames[MAX_ARGUMENTS];         // Names of formal arguments
    int  resolved;           // Whether the body expression has been resolved.
    struct TREE_NODE * body; // Point to the expression representing the body of a function
};

// Stores the definitions of functions defined using (define ...)
struct FUNC_DECL functions[MAX_FUNCTIONS];
int numFuncs = 0;

// Global variables
int err_value = 0;
int loading = 0;
int tracing = 0;
int depth = 0;

// Find a builtin function by name
struct BUILTIN_DECL * find_builtin(char *name);

// Find a function by name
struct FUNC_DECL * find_function(char *name);

// Resolve the body of a function to prepare it for evaluation
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf);

// Evaluate a function
int eval(struct TREE_NODE * node, int *env);

// Free a syntax tree that is no longer needed
void free_tree(struct TREE_NODE *node);

int eval_inc(struct TREE_NODE * node, int *env);
int eval_dec(struct TREE_NODE * node, int *env);
int eval_ifz(struct TREE_NODE * node, int *env);

// Support printing when tracing is on
void print_inc(FILE *stream, struct TREE_NODE * node, int *env, int level);
void print_dec(FILE *stream, struct TREE_NODE * node, int *env, int level);
void print_ifz(FILE *stream, struct TREE_NODE * node, int *env, int level);

// The global variable of all builtin functions
struct BUILTIN_DECL builtin_functions[NUM_BUILTIN] = {
    {"inc", 1, &eval_inc, &print_inc},
	{"dec", 1, &eval_dec, &print_dec},
	{"ifz", 3, &eval_ifz, &print_ifz}
};

%}

%%
/********************************************************************************
 * Beginning of Section 3: Grammar production rule definitions and associated   *
 *  C code                                                                      *
 ********************************************************************************/ 

statements:
 statement 
|
 statements statement
;

statement:
  OPENPAR DEFINE OPENPAR ID arg_list CLOSEPAR expr CLOSEPAR     // define a function`
  {
    if (find_builtin($4) != NULL) {
        fprintf(stderr, "Cannot redefine builtin function %s.\n", $4);
    } 
	else if (find_function($4) != NULL) {
        fprintf(stderr, "Function %s already defined.\n", $4);
    } 
	else if ($5-> arg_list.numArgs > MAX_ARGUMENTS) {
        fprintf(stderr, "Sorry, we allow only %d arguments in a function.", MAX_ARGUMENTS);
    } 
	else if (numFuncs == MAX_FUNCTIONS) {
        fprintf(stderr, "Sorry, we allow only %d number of functions to be defined. \n", MAX_FUNCTIONS);
    } 
	else {   // No error, add definition for the function
	    int i;
        functions[numFuncs].name = $4; 
        functions[numFuncs].numArgs = $5->arg_list.numArgs;
		for (i=0; i<$5->arg_list.numArgs; i++) {
            functions[numFuncs].argNames[i] = $5->arg_list.argNames[i];
		}
		free($5);
        functions[numFuncs].body = $7;
		// Do not resolve now, because the body may use function not yet defined. 
        functions[numFuncs].resolved = 0;	
        numFuncs++;
        printf("Function %s defined.\n", $4);
    }
  }
| 
  expr		// An expression
  {
    resolve($1, NULL);
    if (err_value == 0) {
        printf ("%d\n", eval($1, NULL)); 
    }
    free_tree($1);
    err_value = 0;
  }
;

arg_list:
  ID 
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_LIST;
    node -> arg_list.numArgs = 1;
    node -> arg_list.argNames[0] = $1;
    $$ = node;
  }
| arg_list ID
  {
    if ($1 -> arg_list.numArgs >= MAX_ARGUMENTS) {
        fprintf (stderr, "Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);		
        free($2);
		err_value = 1;
    } else {
        $1 -> arg_list.argNames[$1->arg_list.numArgs] = $2;
        $1 -> arg_list.numArgs++;
    }
    $$ = $1;
  }
  
expr_list:        
  expr
  {
    // expr_list can be used only as actual arguments in a function invocation
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = FUNC_CALL;
    node -> func_call.numArgs = 1;
    node -> func_call.args[0] = $1;
    $$ = node;
  }
| expr_list expr
  {
    if ($1 -> func_call.numArgs >= MAX_ARGUMENTS) {
        printf ("Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);
        free_tree($2);
		err_value = 2;
    } else {
        $1 -> func_call.args[$1->func_call.numArgs] = $2;
        $1 -> func_call.numArgs++;
    }
    $$ = $1;
  }
;
  
expr: 
  OPENPAR HALT CLOSEPAR
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = HALT_NODE;
    $$ = node;
  }
|
  NUMBER
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = NUMBER_NODE;
    node -> intValue = $1;
    $$ = node;
  }
|
  ID
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_NAME;
    node -> strValue = $1;
    $$ = node;
  }
|
 OPENPAR ID expr_list CLOSEPAR
  {
    struct BUILTIN_DECL *builtin = find_builtin($2);
    $3 -> func_call.name = $2;
	if (builtin != NULL) {	// Usage of a built-in function
	    if (builtin->numArgs != $3->func_call.numArgs) {
		    fprintf (stderr, "The built-in function %s expects %d arguments; you have %d.", 
			                 builtin->name, builtin->numArgs, $3->func_call.numArgs);
			err_value = 3;
		} else {
	        $3 -> type = BUILTIN_FUNC;
		    $3 -> builtin_func.decl = builtin;
            free($2);			// Name string no longer needed
		}
    }
    $$ = $3;
  }
;

%%
/********************************************************************************
 * Beginning of Section 4: C functions to be included in the y.tab.c.           *
 ********************************************************************************/ 

/* Free an expression tree that is no longer needed.  */
void free_tree(struct TREE_NODE * node)
{
    int i;
    switch(node->type)
    {
        case NUMBER_NODE:
        case ARG_INDEX:
        case HALT_NODE:
            break;
        case ARG_NAME:        
            free(node->strValue);
            break;
        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                free_tree(node->builtin_func.args[i]);
            }
            break;
        case FUNC_EVAL:
            for (i=0; i<node->func_eval.numArgs; i++) {
                free_tree(node->func_eval.args[i]);
            }
            break;
        case FUNC_CALL:
            free(node->func_call.name);
            for (i=0; i<node->func_call.numArgs; i++) {
                free_tree(node->func_call.args[i]);
            }
            break;
        case ARG_LIST:
            for (i=0; i<node->arg_list.numArgs; i++) {
                free(node->arg_list.argNames[i]);
            }
            break;
        default:
            fprintf(stderr, "Unexpected node type during freeing.\n");
            exit(1);
    }
    free(node);
}

/* Print an expression when tracing is on */
void print_node(struct TREE_NODE * node, int *env, int level)
{
    int i;
    struct FUNC_DECL *f;
    switch(node->type)
    {
        case NUMBER_NODE:
            printf (" %d", node->intValue);
            return;
        case ARG_INDEX:
            printf (" %d", env[node->intValue]);
            return;
        case BUILTIN_FUNC:
			node->builtin_func.decl->print(stdout, node, env, level);
            return;
        case HALT_NODE:
            printf (" (halt)");
            return;
        case FUNC_EVAL:
            f = node->func_eval.func;
            printf (" (%s", f->name);
            for (i=0; i<f->numArgs; i++) {
                if (level == 0) {
                    printf(" ..");
                } else {
                    print_node(node->func_eval.args[i], env, level-1);
                }
            }
            printf (")");
            return;
        default:
            fprintf(stderr, "Unexpected node type during evaluation.\n");
            exit(1);
    }
}

struct BUILTIN_DECL * find_builtin(char *name)
{
    int i;
    for (i=0; i<NUM_BUILTIN; i++) {
        if (strcmp(builtin_functions[i].name, name) == 0)
            return &builtin_functions[i];
    }
    return NULL;
}

 
struct FUNC_DECL * find_function(char *name)
{
    int i;
    for (i=0; i<numFuncs; i++) {
        if (! strcmp(functions[i].name, name))
            return &functions[i];
    }
    return NULL;
}

/* Resolve an expression pointed to by node, possibly in the context of a function 
   body.  */
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf)
{
    struct FUNC_DECL *f = NULL;

    int i;
    switch(node->type)
    {
        case ARG_NAME:        // Use of an argument
            if (cf != NULL) { //
                for (i=0; i<cf->numArgs; i++) {
                    if (! strcmp(node->strValue, cf->argNames[i])) {
                        free(node->strValue);
                        node->type = ARG_INDEX;
                        node->intValue = i;
                        break;
                    }
                }
            }
            if (node->type != ARG_INDEX) {
                fprintf(stderr, "Usage of identifier %s undefined\n", node->strValue);
                err_value = 1;
            }
            break;
            
        case FUNC_CALL:
            f = find_function(node->func_call.name);
            if (f == NULL) {
                fprintf(stderr, "Function %s not found\n", node->func_call.name);
                err_value = 1;
                break;
            }
            if (f->numArgs != node->func_call.numArgs) {
                fprintf(stderr, "Usage of function %s has %d arguments, definition of function %s has %d arguments.\n", 
                       f->name, node->func_eval.numArgs, f->name, f->numArgs);
                err_value = 1;
                break;
            }
            free(node->func_call.name);
            for (i=0; i<f->numArgs; i++) {
                resolve(node->func_call.args[i], cf);
            }
            node->type = FUNC_EVAL;
            node->func_eval.func = f;
            break;

        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                resolve(node->builtin_func.args[i], cf);
            }
			break;
    }
}

//Evaluates an expression node
int eval(struct TREE_NODE * node, int *env)
{
    struct FUNC_DECL   *f;
    int i, v;
    int e[MAX_ARGUMENTS];
    depth ++;

    switch(node->type)
    {
        case NUMBER_NODE:
            v = node->intValue;
            break;
        case ARG_INDEX:
            v = env[node->intValue];
            break;
        case BUILTIN_FUNC:
            v= (node->builtin_func.decl->body)(node, env);
            break;

        case HALT_NODE:
            fprintf(stderr, "Halted\n");
            exit(1);
            
        case FUNC_EVAL:
            f = node->func_eval.func;
            if (! f->resolved) {
                resolve(f->body, f);
            }
            
            for (i=0; i<f->numArgs; i++) {
                e[i] = eval(node->func_eval.args[i], env);
            }
            
            if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("Evaluating (%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]);
                }
                printf(")\n");
            }
            
            v = eval(f->body, e);
            
            if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("(%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]);
                }
                printf(") = %d\n", v);
            }
            break;

        default:
            fprintf (stderr, "Unexpected node %d\n", node->type); 
            exit(3);
    }
    depth --;
    return v;
}

/*********************************************************
 * Begin of supporting code for the built-in functions.  *
 *********************************************************/

int eval_inc(struct TREE_NODE * node, int *env)
{
    return eval(node->builtin_func.args[0], env) + 1;
}

void print_inc(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
	fprintf (stream, " (inc ..)");
}
            
int eval_dec(struct TREE_NODE * node, int *env)
{
    int v = eval(node->builtin_func.args[0], env) - 1;
	if (v < 0) {
	    fprintf(stderr, "Encountering a negative number.  Exiting.\n");
		exit(1);
	}
	return v;
}

void print_dec(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
	fprintf (stream, " (dec ..)");
}

int eval_ifz(struct TREE_NODE * node, int *env)
{
    int i;
    int v = eval(node->builtin_func.args[0], env);
            
    if (tracing) {
        for (i=0; i<depth; i++) {
            printf (" ");
        }
        printf("Evaluating (ifz %d", v);
        print_node(node->builtin_func.args[1], env, 2);
        print_node(node->builtin_func.args[2], env, 2);
        printf(")\n");
    }

    if (v == 0) 
        v = eval(node->builtin_func.args[1], env);
    else
        v = eval(node->builtin_func.args[2], env);
    return v;
}

void print_ifz(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
    if (level == 0) {
        printf (" (ifz .. .. ..)");
    } else {
        printf (" (ifz");
        print_node(node->builtin_func.args[0], env, level-1);
        print_node(node->builtin_func.args[1], env, level-1);
        print_node(node->builtin_func.args[2], env, level-1);
        printf (")");
    }
}

/*********************************************************
 * End of supporting code for the built-in functions.  *
 *********************************************************/

void yyerror(const char * s)
{
    fprintf(stderr,"%s", s);
}

void prompt()
{
    if (! loading) {
        printf("fiz> ");
    }
}

main(int argc, char *argv[])
{
    prompt();
    yyparse();
    return 0;
}
    
